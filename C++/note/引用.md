# 引用（普通引用）

## 1\. 引用的概念

- 引用可以看作一个已定义变量的别名
- 引用的语法：`Type& name = var;`
- 引用做函数参数那？（引用作为函数参数声明时不进行初始化）
- 引用是C++的概念，不要用C的语法来考虑引用

## 2\. 引用做函数参数

- 普通引用在声明时必须用其它的变量进行初始化
- 引用作为函数参数声明时不进行初始化

## 3\. 引用的意义

- 引用作为其它变量的别名而存在，因此在一些场合可以代替指针
- 引用相对于指针来说具有更好的可读性和实用性

## 4\. 引用的本质

**引用在C++中的内部实现是一个常量指针： Type & name <==> Type * const name**

C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。

```cpp
void func(int &a) {
    a = 5;
}
void func(int *const a) {
    *a = 5;
}
```

当我们使用引用语法的时，我们不去关心编译器引用是怎么做的 当我们分析奇怪的语法现象的时，我们才去考虑c++编译器是怎么做的

## 5\. 当函数返回值是引用（引用当左值）

- 当函数返回值为引用时 若返回栈变量 不能成为其它引用的初始值 不能作为左值使用

- 若返回静态变量或全局变量 可以成为其他引用的初始值 即可作为右值使用，也可作为左值使用

```cpp
int& j()
{
    static int a = 10;
    a++;
    printf("a:%d\n", a);
    return a;
}
int *j2()
{
    static int a = 10;
    a++;
    printf("a:%d\n", a);
    return &a;
}

int main()
{
    j() = 100; // 编译器帮我们做了一些事情：返回的是a的引用（内存地址），可以赋值。
    j();

    *(j2()) = 200; // 自己手动赋值，跟上面代码一样，只不过上面代码编译器帮我们做了
    j2();

    return 0;
}
```

## 6\. 指针引用
